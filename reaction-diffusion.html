<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reaction Diffusion</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0a0a;
      overflow: hidden;
      height: 100vh;
    }

    canvas {
      display: block;
      border-radius: 20px;
    }

    .scanlines {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: repeating-linear-gradient(
        0deg,
        rgba(0, 0, 0, 0.15) 0px,
        rgba(0, 0, 0, 0.15) 1px,
        transparent 1px,
        transparent 3px
      );
      z-index: 10;
    }

    .vignette {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: radial-gradient(
        ellipse at center,
        transparent 0%,
        transparent 50%,
        rgba(0, 0, 0, 0.4) 100%
      );
      z-index: 11;
    }

    .crt {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 12;
      animation: flicker 0.15s infinite;
      opacity: 0.03;
      background: white;
    }

    @keyframes flicker {
      0% { opacity: 0.003; }
      50% { opacity: 0.008; }
      100% { opacity: 0.003; }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="scanlines"></div>
  <div class="vignette"></div>
  <div class="crt"></div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    let simWidth, simHeight;
    let gridA, gridB, nextA, nextB;
    let imageData;
    let simCanvas, simCtx;
    let simScale = 1;
    let params = {
      feed: 0.055,
      kill: 0.062,
      da: 1.0,
      db: 0.5,
      dt: 1.0
    };
    let time = 0;
    let lastSeedTime = 0;
    let lastResetTime = 0;
    let paletteIndex = 0;
    const targetResolution = 360;
    const stepsPerFrame = 12;
    const seedIntervalMs = 5000;
    const resetIntervalMs = 60000;
    const palettes = [
      { low: [12, 18, 24], high: [78, 122, 145] },
      { low: [16, 16, 28], high: [118, 92, 140] },
      { low: [10, 22, 18], high: [88, 132, 110] },
      { low: [18, 14, 10], high: [140, 104, 72] }
    ];

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      initGrid();
    }

    function initGrid() {
      simScale = Math.max(width, height) / targetResolution;
      simScale = Math.max(1, simScale);
      simWidth = Math.max(2, Math.floor(width / simScale));
      simHeight = Math.max(2, Math.floor(height / simScale));
      const size = simWidth * simHeight;
      gridA = new Float32Array(size);
      gridB = new Float32Array(size);
      nextA = new Float32Array(size);
      nextB = new Float32Array(size);
      simCanvas = document.createElement('canvas');
      simCanvas.width = simWidth;
      simCanvas.height = simHeight;
      simCtx = simCanvas.getContext('2d');
      imageData = simCtx.createImageData(simWidth, simHeight);

      for (let i = 0; i < size; i++) {
        gridA[i] = 1.0;
        gridB[i] = 0.0;
      }

      const cx = Math.floor(simWidth / 2);
      const cy = Math.floor(simHeight / 2);
      const r = Math.floor(Math.min(simWidth, simHeight) * 0.08);

      for (let y = cy - r; y < cy + r; y++) {
        for (let x = cx - r; x < cx + r; x++) {
          if (x >= 0 && x < width && y >= 0 && y < height) {
            const idx = y * width + x;
            gridB[idx] = 1.0;
          }
        }
      }

      setTimeout(() => {
        autoSeed();
        autoSeed();
      }, 100);

      lastSeedTime = performance.now();
      lastResetTime = lastSeedTime;
    }

    function laplacian(idx, grid) {
      let sum = 0;
      const w = simWidth;

      sum += grid[idx] * -1;
      sum += grid[idx - 1] * 0.2;
      sum += grid[idx + 1] * 0.2;
      sum += grid[idx - w] * 0.2;
      sum += grid[idx + w] * 0.2;
      sum += grid[idx - w - 1] * 0.05;
      sum += grid[idx - w + 1] * 0.05;
      sum += grid[idx + w - 1] * 0.05;
      sum += grid[idx + w + 1] * 0.05;

      return sum;
    }

    function update() {
      for (let y = 1; y < simHeight - 1; y++) {
        for (let x = 1; x < simWidth - 1; x++) {
          const idx = y * simWidth + x;
          const a = gridA[idx];
          const b = gridB[idx];
          const lapA = laplacian(idx, gridA);
          const lapB = laplacian(idx, gridB);

          let newA = a + (params.da * lapA - a * b * b + params.feed * (1 - a)) * params.dt;
          let newB = b + (params.db * lapB + a * b * b - (params.kill + params.feed) * b) * params.dt;

          newA = Math.max(0, Math.min(1, newA));
          newB = Math.max(0, Math.min(1, newB));

          nextA[idx] = newA;
          nextB[idx] = newB;
        }
      }

      [gridA, nextA] = [nextA, gridA];
      [gridB, nextB] = [nextB, gridB];
    }

    function seed(x, y, r) {
      const ix = Math.floor(x);
      const iy = Math.floor(y);
      for (let dy = -r; dy <= r; dy++) {
        for (let dx = -r; dx <= r; dx++) {
          const px = ix + dx;
          const py = iy + dy;
          if (px >= 0 && px < simWidth && py >= 0 && py < simHeight) {
            const idx = py * simWidth + px;
            if (Math.random() < 0.5) {
              gridB[idx] = 1.0;
            }
          }
        }
      }
    }

    function autoSeed() {
      const x = Math.random() * simWidth;
      const y = Math.random() * simHeight;
      const r = Math.floor(6 + Math.random() * 12);
      seed(x, y, r);
    }

    function clearGrid() {
      for (let i = 0; i < gridA.length; i++) {
        gridA[i] = 1.0;
        gridB[i] = 0.0;
      }
    }

    function nextPalette() {
      paletteIndex = (paletteIndex + 1) % palettes.length;
    }

    function colorFromPalette(val) {
      const p = palettes[paletteIndex];
      const t = Math.max(0, Math.min(1, val));
      const r = Math.floor(p.low[0] + (p.high[0] - p.low[0]) * t);
      const g = Math.floor(p.low[1] + (p.high[1] - p.low[1]) * t);
      const b = Math.floor(p.low[2] + (p.high[2] - p.low[2]) * t);
      return [r, g, b];
    }

    function draw() {
      const data = imageData.data;

      for (let i = 0; i < gridA.length; i++) {
        const a = gridA[i];
        const b = gridB[i];
        const c = Math.floor((a - b) * 255);
        const val = Math.max(0, Math.min(255, c));
        const t = val / 255;
        const [r, g, bcol] = colorFromPalette(t);

        const idx = i * 4;
        data[idx] = r;
        data[idx + 1] = g;
        data[idx + 2] = bcol;
        data[idx + 3] = 255;
      }

      simCtx.putImageData(imageData, 0, 0);
      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0, 0, width, height);
      ctx.drawImage(simCanvas, 0, 0, width, height);

      for (let i = 0; i < stepsPerFrame; i++) {
        update();
      }

      const now = performance.now();
      if (now - lastSeedTime >= seedIntervalMs) {
        autoSeed();
        lastSeedTime = now;
      }

      if (now - lastResetTime >= resetIntervalMs) {
        clearGrid();
        autoSeed();
        autoSeed();
        nextPalette();
        lastResetTime = now;
      }

      time++;
      requestAnimationFrame(draw);
    }

    canvas.addEventListener('click', (e) => {
      const x = Math.floor(e.clientX / simScale);
      const y = Math.floor(e.clientY / simScale);
      seed(x, y, 10);
    });

    window.addEventListener('resize', resize);
    resize();
    draw();
  </script>
</body>
</html>
