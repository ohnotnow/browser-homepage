<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>L-System Garden</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0a0a;
      overflow: hidden;
      height: 100vh;
    }

    canvas {
      display: block;
      border-radius: 20px;
    }

    /* Scanline overlay */
    .scanlines {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: repeating-linear-gradient(
        0deg,
        rgba(0, 0, 0, 0.15) 0px,
        rgba(0, 0, 0, 0.15) 1px,
        transparent 1px,
        transparent 3px
      );
      z-index: 10;
    }

    /* Vignette effect */
    .vignette {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: radial-gradient(
        ellipse at center,
        transparent 0%,
        transparent 50%,
        rgba(0, 0, 0, 0.4) 100%
      );
      z-index: 11;
    }

    /* Subtle screen flicker */
    .crt {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 12;
      animation: flicker 0.15s infinite;
      opacity: 0.03;
      background: white;
    }

    @keyframes flicker {
      0% { opacity: 0.02; }
      50% { opacity: 0.04; }
      100% { opacity: 0.02; }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="scanlines"></div>
  <div class="vignette"></div>
  <div class="crt"></div>

  <script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl', { antialias: true, premultipliedAlpha: false });

    if (!gl) {
      throw new Error('WebGL not supported.');
    }

    const vertexSource = `
      attribute vec2 a_pos;
      void main() {
        gl_Position = vec4(a_pos, 0.0, 1.0);
      }
    `;

    const fragmentSource = `
      precision highp float;
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform vec2 u_offsetA;
      uniform vec2 u_offsetB;
      uniform vec2 u_offsetC;
      uniform float u_scaleA;
      uniform float u_scaleB;
      uniform float u_scaleC;
      uniform vec3 u_paramsA;
      uniform vec3 u_paramsB;
      uniform vec3 u_paramsC;
      uniform sampler2D u_trail;
      uniform float u_pass;
      uniform float u_decay;

      #define PI 3.14159
      #define MAXDEPTH 7

      mat3 Rot (float angle)
      {
          float c = cos(angle);
          float s = sin(angle);
          return  mat3(
              vec3(c, s, 0.0),
              vec3(-s, c, 0.0),
              vec3(0.0, 0.0, 1.0)
          ); 
      }

      mat3 Disp (vec2 displacement)
      {
          return  mat3(
              vec3(1.0, 0.0, 0.0),
              vec3(0.0, 1.0, 0.0),
              vec3(displacement, 1.0)
          ); 
      }

      float sdCappedCylinder( vec2 p, vec2 h )
      {
        p -= vec2(0.0,h.y);
        vec2 d = abs(vec2(length(p.x),p.y)) - h;
        return min(max(d.x,d.y),0.0) + length(max(d,0.0));
      }

      float left(vec2 pt, vec3 params)
      {
          float angleMul = params.x;
          float lenMul = params.y;
          float windMul = params.z;
          mat3 posR = Rot(-(20.0*angleMul/360.0)*2.0*PI);
          mat3 negR = Rot(20.0*angleMul/360.0*2.0*PI);

          const int depth = 6;
          const int branches = 3; 
          int maxDepth = int(pow(float(branches), float(depth)));
          float len = 1.7 * lenMul;
          float wid = 0.01;
          pt = pt + vec2(0.0,2.0);

          float trunk = sdCappedCylinder(pt-vec2(0.0,0.0), vec2(wid,len));
          float d = 500.0;

          int c = 0;

          for (int count = 0; count <= 100; ++count){
            int off = int(pow(float(branches), float(depth)));

            vec2 pt_n = pt;
            for (int i = 1; i <= depth; ++i)
            {
              float l = len/pow(2.0,float(i));

              off /= branches; 
              int dec = c / off;
              int path = dec - branches*(dec/branches);

              mat3 mx;
              if(path == 0){
                mx = posR*Disp(vec2(0.0,-2.0*l));
              }
              else if(path == 1){
                mat3 wind = Rot(0.5*windMul*sin(u_time + 2.0));
                mx = wind*posR * Disp(vec2(0.0,-4.0*l));
              }
              else if(path == 2){
                mat3 wind = Rot(0.2*windMul*sin(u_time));
                mx = wind*negR * Disp(vec2(0.0,-4.0*l));
              }

              pt_n = (mx * vec3(pt_n,1.0)).xy;
              float y = sdCappedCylinder(pt_n, vec2(wid,l));

              if( y-2.0*l > 0.0 ) { c += off-1; break; }
                d = min( d, y );
           }

          ++c;
          if (c > maxDepth) break;
          }
         return min(d,trunk);
      }

      float center(vec2 pt, vec3 params)
      {
          float angleMul = params.x;
          float lenMul = params.y;
          float windMul = params.z;
          mat3 posR = Rot(-(25.7*angleMul/360.0)*2.0*PI);
          mat3 negR = Rot(25.7*angleMul/360.0*2.0*PI);

          const int depth = 7;
          const int branches = 3; 
          int maxDepth = int(pow(float(branches), float(depth)));
          float len = 1.7 * lenMul;
          float wid = 0.01;
          pt = pt + vec2(0.0,2.0);

          float trunk = sdCappedCylinder(pt-vec2(0.0,0.0), vec2(wid,len));
          float d = 500.0;

          int c = 0;
          for (int count = 0; count <= 100; ++count){
            int off = int(pow(float(branches), float(depth)));
            vec2 pt_n = pt;
            for (int i = 1; i <= depth; ++i)
            {
              float l = len/pow(2.0,float(i));

              off /= branches; 
              int dec = c / off;
              int path = dec - branches*(dec/branches);

              mat3 mx;
              if(path == 0){
                mx = posR*Disp(vec2(0.0,-2.0*l));
              }
              else if(path == 1){
                mat3 wind = Rot(0.2*windMul*sin(u_time+6.2));
                mx = wind*negR*Disp(vec2(0.0,-2.0*l));
              }
              else if(path == 2){
                mat3 wind = Rot(0.2*windMul*sin(u_time+1.0));
                mx = wind*Disp(vec2(0.0,-4.0*l)) ;
              }

              pt_n = (mx * vec3(pt_n,1.0)).xy;
              float y = sdCappedCylinder(pt_n, vec2(wid,l));   

              if( y-2.0*l > 0.0 ) { c += off-1; break; }
                d = min( d, y );
           }

          ++c;
          if (c > maxDepth) break;
          }
         return min(d,trunk); 
      }

      float right_p(vec2 pt, float wid, float len)
      {
          mat3 posR = Rot(-(22.5/360.0)*2.0*PI);

          float t1 = sdCappedCylinder(pt, vec2(wid,len));
          vec2 pt_t2 = (posR*Disp(vec2(0.0,-2.0*len))* vec3(pt,1.0)).xy;
          float t2 = sdCappedCylinder(pt_t2, vec2(wid,len/2.0));
          return min(t1, t2);
      }

      float right(vec2 pt, vec3 params)
      {
          float angleMul = params.x;
          float lenMul = params.y;
          float windMul = params.z;
          mat3 posR = Rot(-(22.5*angleMul/360.0)*2.0*PI);
          mat3 negR = Rot(22.5*angleMul/360.0*2.0*PI);

          const int depth = 4;
          const int branches = 4; 
          int maxDepth = int(pow(float(branches), float(depth)));
          float len = 1.3 * lenMul;
          float wid = 0.01;
          pt = pt + vec2(0.0,2.0);

          float trunk = right_p(pt, wid, len);
          float d = 500.0;

          int c = 0;
          for (int count = 0; count <= 110; ++count){
            int off = int(pow(float(branches), float(depth)));
            vec2 pt_n = pt;

            for (int i = 1; i <= depth; ++i)
            {
              float l = len/pow(2.0,float(i));

              off /= branches; 
              int dec = c / off;
              int path = dec - branches*(dec/branches);

              mat3 mx;
              if(path == 0){
                mx = negR*Disp(vec2(0.0,-2.0*l));
              }
              else if(path == 1){
                mat3 wind = Rot(0.6*windMul*sin(u_time/2.0));
                mx = wind*negR*Disp(vec2(0.0,-4.0*l));
              }
              else if(path == 2){
                mx = Disp(vec2(0.0,-2.0*l));
              }
              else if(path == 3){
                mx = Disp(vec2(0.0,-2.0*l))*posR*Disp(vec2(0.0,-4.0*l));
              }

              pt_n = (mx* vec3(pt_n,1.0)).xy; 
              float y = right_p(pt_n, wid, l); 

              if( y-3.0*l > 0.0 ) { c += off-1; break; }
                d = min( d, y );
           }

          ++c;
          if (c > maxDepth) break;
          }
         return min(d,trunk);
      }

      float treeMask(vec2 uv) {
          vec2 uva = uv * u_scaleA + u_offsetA;
          vec2 uvb = uv * u_scaleB + u_offsetB;
          vec2 uvc = uv * u_scaleC + u_offsetC;

          float l = left(uva - vec2(-5.0,0.0), u_paramsA);
          float c = center(uvb, u_paramsB);
          float r = right(uvc - vec2(5.0,0.0), u_paramsC);
          float d = min(r, min(l, c));
          float t = clamp(d, 0.0, 0.04) * 2.0*12.5;
          return 1.0 - t;
      }

      void mainImage( out vec4 fragColor, in vec2 fragCoord )
      {
          vec2 uv = fragCoord.xy / u_resolution.xy;
          uv = uv * 2.0 - 1.0;		
          uv.x *= u_resolution.x / u_resolution.y;
          uv *= 5.0;

          // Subtle vertical drift and occasional horizontal glitch.
          float drift = 0.3 * sin(u_time * 0.1);
          uv.y += drift;
          float band = smoothstep(0.0, 0.02, abs(sin((uv.y * 3.0 + u_time * 0.9) * 6.0)));
          float glitch = step(0.985, fract(sin(u_time * 0.7) * 43758.5453));
          uv.x += (0.08 + 0.06 * sin(u_time * 3.0)) * glitch * band;

          vec2 offset = vec2(0.16, 0.0);

          if (u_pass < 0.5) {
            float trail = treeMask(uv + offset);
            float shift = 6.0 + 2.0 * sin(u_time * 0.25);
            vec2 baseUv = (fragCoord.xy + vec2(shift, 0.0)) / u_resolution.xy;
            float prev = texture2D(u_trail, baseUv).r;
            float prevBlur = texture2D(u_trail, baseUv + vec2(1.0 / u_resolution.x, 0.0)).r;
            prev = 0.6 * prev + 0.4 * prevBlur;
            float nextTrail = max(trail, prev * u_decay);
            fragColor = vec4(nextTrail, 0.0, 0.0, 1.0);
            return;
          }

          vec3 bg = vec3(0.0);
          vec3 fg = vec3(0.74, 0.82, 0.74);
          vec3 accent = vec3(0.82, 0.32, 0.36);

          float mask = treeMask(uv);
          float trail = texture2D(u_trail, fragCoord.xy / u_resolution.xy).r;
          float trailGlow = smoothstep(0.0, 1.0, trail) * 0.22;

          // Faint reflection in the lower third.
          vec2 reflUv = uv;
          reflUv.y = -uv.y - 1.0;
          float refl = treeMask(reflUv) * smoothstep(-0.2, -1.0, uv.y) * 0.18;

          vec3 color = mix(bg, fg, mask * 0.8);
          color += accent * (trail * 0.42 + trailGlow);
          color += fg * refl;

          fragColor = vec4(color, 1.0);
      }

      void main() {
        vec4 color;
        mainImage(color, gl_FragCoord.xy);
        gl_FragColor = color;
      }
    `;

    function compileShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(shader);
        gl.deleteShader(shader);
        throw new Error(info || 'Shader compile failed.');
      }
      return shader;
    }

    function createProgram(vertexSrc, fragmentSrc) {
      const program = gl.createProgram();
      gl.attachShader(program, compileShader(gl.VERTEX_SHADER, vertexSrc));
      gl.attachShader(program, compileShader(gl.FRAGMENT_SHADER, fragmentSrc));
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const info = gl.getProgramInfoLog(program);
        gl.deleteProgram(program);
        throw new Error(info || 'Program link failed.');
      }
      return program;
    }

    const program = createProgram(vertexSource, fragmentSource);
    const positionLoc = gl.getAttribLocation(program, 'a_pos');
    const resolutionLoc = gl.getUniformLocation(program, 'u_resolution');
    const timeLoc = gl.getUniformLocation(program, 'u_time');
    const offsetALoc = gl.getUniformLocation(program, 'u_offsetA');
    const offsetBLoc = gl.getUniformLocation(program, 'u_offsetB');
    const offsetCLoc = gl.getUniformLocation(program, 'u_offsetC');
    const scaleALoc = gl.getUniformLocation(program, 'u_scaleA');
    const scaleBLoc = gl.getUniformLocation(program, 'u_scaleB');
    const scaleCLoc = gl.getUniformLocation(program, 'u_scaleC');
    const paramsALoc = gl.getUniformLocation(program, 'u_paramsA');
    const paramsBLoc = gl.getUniformLocation(program, 'u_paramsB');
    const paramsCLoc = gl.getUniformLocation(program, 'u_paramsC');
    const trailLoc = gl.getUniformLocation(program, 'u_trail');
    const passLoc = gl.getUniformLocation(program, 'u_pass');
    const decayLoc = gl.getUniformLocation(program, 'u_decay');

    const quad = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quad);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
        -1,  1,
         1, -1,
         1,  1
      ]),
      gl.STATIC_DRAW
    );

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
      resizeTrailTargets();
    }

    const trailScale = 0.4;
    const trailDecay = 0.95;
    let trailTargets = [];
    let trailIndex = 0;

    function createTrailTarget(width, height) {
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        gl.RGBA,
        width,
        height,
        0,
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        null
      );

      const framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

      return { texture, framebuffer, width, height };
    }

    function resizeTrailTargets() {
      const width = Math.max(1, Math.floor(canvas.width * trailScale));
      const height = Math.max(1, Math.floor(canvas.height * trailScale));

      trailTargets.forEach((target) => {
        gl.deleteTexture(target.texture);
        gl.deleteFramebuffer(target.framebuffer);
      });

      trailTargets = [createTrailTarget(width, height), createTrailTarget(width, height)];
      trailIndex = 0;

      trailTargets.forEach((target) => {
        gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);
        gl.viewport(0, 0, target.width, target.height);
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
      });

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    const treeParams = {
      offsetA: [0, 0],
      offsetB: [0, 0],
      offsetC: [0, 0],
      scaleA: 1,
      scaleB: 1,
      scaleC: 1,
      paramsA: [1, 1, 1],
      paramsB: [1, 1, 1],
      paramsC: [1, 1, 1]
    };

    function randomizeTrees() {
      const jitterX = 1.4;
      const jitterY = 0.6;
      const scaleMin = 0.85;
      const scaleMax = 1.12;
      const angleMin = 0.75;
      const angleMax = 1.35;
      const lenMin = 0.8;
      const lenMax = 1.25;
      const windMin = 0.6;
      const windMax = 1.6;

      treeParams.offsetA = [(Math.random() * 2 - 1) * jitterX, (Math.random() * 2 - 1) * jitterY];
      treeParams.offsetB = [(Math.random() * 2 - 1) * jitterX, (Math.random() * 2 - 1) * jitterY];
      treeParams.offsetC = [(Math.random() * 2 - 1) * jitterX, (Math.random() * 2 - 1) * jitterY];
      treeParams.scaleA = scaleMin + Math.random() * (scaleMax - scaleMin);
      treeParams.scaleB = scaleMin + Math.random() * (scaleMax - scaleMin);
      treeParams.scaleC = scaleMin + Math.random() * (scaleMax - scaleMin);
      treeParams.paramsA = [
        angleMin + Math.random() * (angleMax - angleMin),
        lenMin + Math.random() * (lenMax - lenMin),
        windMin + Math.random() * (windMax - windMin)
      ];
      treeParams.paramsB = [
        angleMin + Math.random() * (angleMax - angleMin),
        lenMin + Math.random() * (lenMax - lenMin),
        windMin + Math.random() * (windMax - windMin)
      ];
      treeParams.paramsC = [
        angleMin + Math.random() * (angleMax - angleMin),
        lenMin + Math.random() * (lenMax - lenMin),
        windMin + Math.random() * (windMax - windMin)
      ];
    }

    function render(timeMs) {
      const time = timeMs * 0.001;
      const readTarget = trailTargets[trailIndex];
      const writeTarget = trailTargets[1 - trailIndex];

      gl.useProgram(program);
      gl.bindBuffer(gl.ARRAY_BUFFER, quad);
      gl.enableVertexAttribArray(positionLoc);
      gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
      gl.uniform1f(timeLoc, time);
      gl.uniform2f(offsetALoc, treeParams.offsetA[0], treeParams.offsetA[1]);
      gl.uniform2f(offsetBLoc, treeParams.offsetB[0], treeParams.offsetB[1]);
      gl.uniform2f(offsetCLoc, treeParams.offsetC[0], treeParams.offsetC[1]);
      gl.uniform1f(scaleALoc, treeParams.scaleA);
      gl.uniform1f(scaleBLoc, treeParams.scaleB);
      gl.uniform1f(scaleCLoc, treeParams.scaleC);
      gl.uniform3f(paramsALoc, treeParams.paramsA[0], treeParams.paramsA[1], treeParams.paramsA[2]);
      gl.uniform3f(paramsBLoc, treeParams.paramsB[0], treeParams.paramsB[1], treeParams.paramsB[2]);
      gl.uniform3f(paramsCLoc, treeParams.paramsC[0], treeParams.paramsC[1], treeParams.paramsC[2]);

      gl.activeTexture(gl.TEXTURE0);
      gl.uniform1i(trailLoc, 0);
      gl.uniform1f(decayLoc, trailDecay);

      gl.bindFramebuffer(gl.FRAMEBUFFER, writeTarget.framebuffer);
      gl.viewport(0, 0, writeTarget.width, writeTarget.height);
      gl.uniform2f(resolutionLoc, writeTarget.width, writeTarget.height);
      gl.uniform1f(passLoc, 0.0);
      gl.bindTexture(gl.TEXTURE_2D, readTarget.texture);
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
      gl.uniform1f(passLoc, 1.0);
      gl.bindTexture(gl.TEXTURE_2D, writeTarget.texture);
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      trailIndex = 1 - trailIndex;
      requestAnimationFrame(render);
    }

    window.addEventListener('resize', resize);
    resize();
    randomizeTrees();
    setInterval(randomizeTrees, 60000);
    requestAnimationFrame(render);
  </script>
</body>
</html>
