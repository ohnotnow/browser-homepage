<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>L-System Garden</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0a0a;
      overflow: hidden;
      height: 100vh;
    }

    canvas {
      display: block;
      border-radius: 20px;
    }

    /* Scanline overlay */
    .scanlines {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: repeating-linear-gradient(
        0deg,
        rgba(0, 0, 0, 0.15) 0px,
        rgba(0, 0, 0, 0.15) 1px,
        transparent 1px,
        transparent 3px
      );
      z-index: 10;
    }

    /* Vignette effect */
    .vignette {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: radial-gradient(
        ellipse at center,
        transparent 0%,
        transparent 50%,
        rgba(0, 0, 0, 0.4) 100%
      );
      z-index: 11;
    }

    /* Subtle screen flicker */
    .crt {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 12;
      animation: flicker 0.15s infinite;
      opacity: 0.03;
      background: white;
    }

    @keyframes flicker {
      0% { opacity: 0.02; }
      50% { opacity: 0.04; }
      100% { opacity: 0.02; }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="scanlines"></div>
  <div class="vignette"></div>
  <div class="crt"></div>

  <script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl', { antialias: true, premultipliedAlpha: false });

    if (!gl) {
      throw new Error('WebGL not supported.');
    }

    const vertexSource = `
      attribute vec2 a_pos;
      void main() {
        gl_Position = vec4(a_pos, 0.0, 1.0);
      }
    `;

    const fragmentSource = `
      precision highp float;
      uniform vec2 u_resolution;
      uniform float u_time;

      #define PI 3.14159
      #define MAXDEPTH 7

      mat3 Rot (float angle)
      {
          float c = cos(angle);
          float s = sin(angle);
          return  mat3(
              vec3(c, s, 0.0),
              vec3(-s, c, 0.0),
              vec3(0.0, 0.0, 1.0)
          ); 
      }

      mat3 Disp (vec2 displacement)
      {
          return  mat3(
              vec3(1.0, 0.0, 0.0),
              vec3(0.0, 1.0, 0.0),
              vec3(displacement, 1.0)
          ); 
      }

      float sdCappedCylinder( vec2 p, vec2 h )
      {
        p -= vec2(0.0,h.y);
        vec2 d = abs(vec2(length(p.x),p.y)) - h;
        return min(max(d.x,d.y),0.0) + length(max(d,0.0));
      }

      float left(vec2 pt)
      {
          mat3 posR = Rot(-(20.0/360.0)*2.0*PI);
          mat3 negR = Rot(20.0/360.0*2.0*PI);

          const int depth = 6;
          const int branches = 3; 
          int maxDepth = int(pow(float(branches), float(depth)));
          float len = 1.7;
          float wid = 0.01;
          pt = pt + vec2(0.0,2.0);

          float trunk = sdCappedCylinder(pt-vec2(0.0,0.0), vec2(wid,len));
          float d = 500.0;

          int c = 0;

          for (int count = 0; count <= 100; ++count){
            int off = int(pow(float(branches), float(depth)));

            vec2 pt_n = pt;
            for (int i = 1; i <= depth; ++i)
            {
              float l = len/pow(2.0,float(i));

              off /= branches; 
              int dec = c / off;
              int path = dec - branches*(dec/branches);

              mat3 mx;
              if(path == 0){
                mx = posR*Disp(vec2(0.0,-2.0*l));
              }
              else if(path == 1){
                mat3 wind = Rot(0.5*sin(u_time + 2.0));
                mx = wind*posR * Disp(vec2(0.0,-4.0*l));
              }
              else if(path == 2){
                mat3 wind = Rot(0.2*sin(u_time));
                mx = wind*negR * Disp(vec2(0.0,-4.0*l));
              }

              pt_n = (mx * vec3(pt_n,1.0)).xy;
              float y = sdCappedCylinder(pt_n, vec2(wid,l));

              if( y-2.0*l > 0.0 ) { c += off-1; break; }
                d = min( d, y );
           }

          ++c;
          if (c > maxDepth) break;
          }
         return min(d,trunk);
      }

      float center(vec2 pt)
      {
          mat3 posR = Rot(-(25.7/360.0)*2.0*PI);
          mat3 negR = Rot(25.7/360.0*2.0*PI);

          const int depth = 7;
          const int branches = 3; 
          int maxDepth = int(pow(float(branches), float(depth)));
          float len = 1.7;
          float wid = 0.01;
          pt = pt + vec2(0.0,2.0);

          float trunk = sdCappedCylinder(pt-vec2(0.0,0.0), vec2(wid,len));
          float d = 500.0;

          int c = 0;
          for (int count = 0; count <= 100; ++count){
            int off = int(pow(float(branches), float(depth)));
            vec2 pt_n = pt;
            for (int i = 1; i <= depth; ++i)
            {
              float l = len/pow(2.0,float(i));

              off /= branches; 
              int dec = c / off;
              int path = dec - branches*(dec/branches);

              mat3 mx;
              if(path == 0){
                mx = posR*Disp(vec2(0.0,-2.0*l));
              }
              else if(path == 1){
                mat3 wind = Rot(0.2*sin(u_time+6.2));
                mx = wind*negR*Disp(vec2(0.0,-2.0*l));
              }
              else if(path == 2){
                mat3 wind = Rot(0.2*sin(u_time+1.0));
                mx = wind*Disp(vec2(0.0,-4.0*l)) ;
              }

              pt_n = (mx * vec3(pt_n,1.0)).xy;
              float y = sdCappedCylinder(pt_n, vec2(wid,l));   

              if( y-2.0*l > 0.0 ) { c += off-1; break; }
                d = min( d, y );
           }

          ++c;
          if (c > maxDepth) break;
          }
         return min(d,trunk); 
      }

      float right_p(vec2 pt, float wid, float len)
      {
          mat3 posR = Rot(-(22.5/360.0)*2.0*PI);

          float t1 = sdCappedCylinder(pt, vec2(wid,len));
          vec2 pt_t2 = (posR*Disp(vec2(0.0,-2.0*len))* vec3(pt,1.0)).xy;
          float t2 = sdCappedCylinder(pt_t2, vec2(wid,len/2.0));
          return min(t1, t2);
      }

      float right(vec2 pt)
      {
          mat3 posR = Rot(-(22.5/360.0)*2.0*PI);
          mat3 negR = Rot(22.5/360.0*2.0*PI);

          const int depth = 4;
          const int branches = 4; 
          int maxDepth = int(pow(float(branches), float(depth)));
          float len = 1.3;
          float wid = 0.01;
          pt = pt + vec2(0.0,2.0);

          float trunk = right_p(pt, wid, len);
          float d = 500.0;

          int c = 0;
          for (int count = 0; count <= 110; ++count){
            int off = int(pow(float(branches), float(depth)));
            vec2 pt_n = pt;

            for (int i = 1; i <= depth; ++i)
            {
              float l = len/pow(2.0,float(i));

              off /= branches; 
              int dec = c / off;
              int path = dec - branches*(dec/branches);

              mat3 mx;
              if(path == 0){
                mx = negR*Disp(vec2(0.0,-2.0*l));
              }
              else if(path == 1){
                mat3 wind = Rot(0.6*sin(u_time/2.0));
                mx = wind*negR*Disp(vec2(0.0,-4.0*l));
              }
              else if(path == 2){
                mx = Disp(vec2(0.0,-2.0*l));
              }
              else if(path == 3){
                mx = Disp(vec2(0.0,-2.0*l))*posR*Disp(vec2(0.0,-4.0*l));
              }

              pt_n = (mx* vec3(pt_n,1.0)).xy; 
              float y = right_p(pt_n, wid, l); 

              if( y-3.0*l > 0.0 ) { c += off-1; break; }
                d = min( d, y );
           }

          ++c;
          if (c > maxDepth) break;
          }
         return min(d,trunk);
      }

      void mainImage( out vec4 fragColor, in vec2 fragCoord )
      {
          vec2 uv = fragCoord.xy / u_resolution.xy;
          uv = uv * 2.0 - 1.0;		
          uv.x *= u_resolution.x / u_resolution.y;
          uv *= 5.0;

          float l = left(uv - vec2(-5.0,0.0));
          float c = center(uv);
          float r = right(uv - vec2(5.0,0.0));
          float d = min(r,min(l, c));

          float t = clamp(d, 0.0, 0.04) * 2.0*12.5;
          vec3 bg = vec3(0.0);
          vec3 fg = vec3(0.86, 0.88, 0.84);
          float mask = 1.0 - t;
          fragColor = vec4(mix(bg, fg, mask), 1.0);
      }

      void main() {
        vec4 color;
        mainImage(color, gl_FragCoord.xy);
        gl_FragColor = color;
      }
    `;

    function compileShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(shader);
        gl.deleteShader(shader);
        throw new Error(info || 'Shader compile failed.');
      }
      return shader;
    }

    function createProgram(vertexSrc, fragmentSrc) {
      const program = gl.createProgram();
      gl.attachShader(program, compileShader(gl.VERTEX_SHADER, vertexSrc));
      gl.attachShader(program, compileShader(gl.FRAGMENT_SHADER, fragmentSrc));
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const info = gl.getProgramInfoLog(program);
        gl.deleteProgram(program);
        throw new Error(info || 'Program link failed.');
      }
      return program;
    }

    const program = createProgram(vertexSource, fragmentSource);
    const positionLoc = gl.getAttribLocation(program, 'a_pos');
    const resolutionLoc = gl.getUniformLocation(program, 'u_resolution');
    const timeLoc = gl.getUniformLocation(program, 'u_time');

    const quad = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quad);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
        -1,  1,
         1, -1,
         1,  1
      ]),
      gl.STATIC_DRAW
    );

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }

    function render(timeMs) {
      gl.useProgram(program);
      gl.bindBuffer(gl.ARRAY_BUFFER, quad);
      gl.enableVertexAttribArray(positionLoc);
      gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
      gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
      gl.uniform1f(timeLoc, timeMs * 0.001);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      requestAnimationFrame(render);
    }

    window.addEventListener('resize', resize);
    resize();
    requestAnimationFrame(render);
  </script>
</body>
</html>
